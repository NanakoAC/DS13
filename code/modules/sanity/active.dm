/*
	This file contains the standard procs for dealing active sanity damage to mobs
*/

/*
	Applies insanity to humans who can see this atom's turf

	Vars:
		Sourcetype: A typepath which must be a subtype of /datum/sanity_source. this will be used to fetch a datum from a global ref list
			This tells us what kind of thing is causing this sanity damage, used for logging and messages

		Quantity: (optional)	How much insanity we are applying. If not specified, the default value will be grabbed from
			the sanity source datum

		Limit: (optional) How high to raise insanity before we start softcapping. If not specified, the default value will be grabbed from
			the sanity source datum

		Source Atom: (optional)	Which specific thing in the world is responsible for causing sanity damage.
			If not specified, src is used
*/
/atom/proc/visible_sanity_damage(var/source_type, var/quantity, var/limit, var/source_datum = null)
	var/datum/sanity_source/S = GLOB.all_sanity_sources[source_type]
	if (!istype(S))
		CRASH("Invalid sanity source: [source_type]")

	quantity = quantity ? quantity : S.quantity
	limit = limit ? limit : S.limit
	source_datum = source_datum ? source_datum : src

	var/list/viewers = get_viewers(maxrange = 10, required_type = /mob/living/carbon/human)
	for (var/mob/living/carbon/human/H as anything in viewers)
		//Ignore necromorphs and lunatics
		if (!H.has_sanity())
			continue


		H.add_active_insanity(S, quantity, limit, source_datum)



/*
	This one is complicated
	Takes all the same vars as above, but in addition, takes a list of sound parameters.
	This list should be the entire set of params you'd input into playsound. Source, file, volume, vary, extrarange, etc.
	They can be simply ordered, or named in an associative list.

	The sound will be played, and this proc will get back a list of who heard it and how loudly. The sanity damage will be scaled by the volume
*/
/atom/proc/audible_sanity_damage(var/source_type, var/quantity = 1, var/limit = 0, var/source_datum = null, var/list/sound_parameters)
	var/datum/sanity_source/S = GLOB.all_sanity_sources[source_type]
	if (!istype(S))
		CRASH("Invalid sanity source: [source_type]")

	quantity = quantity ? quantity : S.quantity
	limit = limit ? limit : S.limit
	source_datum = source_datum ? source_datum : src

	//Listeners is an associative list generated by metered sound proc, in the format mob = volume_they_heard
	var/list/listeners = play_metered_sound(arglist(sound_parameters))
	for (var/mob/living/carbon/human/H in listeners)
		world << "Attempting to apply audible sanity damage to [H]"
		//Ignore necromorphs and lunatics
		if (!H.has_sanity())
			continue

		var/scalar = volume_to_scalar(listeners[H])
		H.add_active_insanity(S, quantity*scalar, limit, source_datum)


//Takes a volume as an input, returns a multiplier in the range 0..1 based on that volume.
//This is not as simple as dividing by 100, volume scales exponentially. I'm not sure of the math for that,
//so as a compromise, we work on comparisons to the volume defines instead, which scale roughly similarly, though they are tuned by ear
//Its good enough to produce a result that feels right
/proc/volume_to_scalar(var/volume)
	if (volume > VOLUME_HIGH)
		return 1
	else if (volume > VOLUME_MID_HIGH)
		return 0.84
	else if (volume > VOLUME_MID)
		return	0.68
	else if (volume > VOLUME_LOW)
		return 0.52
	else if (volume > VOLUME_QUIET)
		return	0.36
	else if (volume > VOLUME_NEAR_SILENT)
		return	0.20
	else
		return 0
